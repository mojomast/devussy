/*
 * scripts/generate-compose.ts
 *
 * Minimal generator that reads AppRegistry service / proxy metadata and writes:
 * - docker-compose.apps.generated.yml
 * - nginx/conf.d/apps.generated.conf
 *
 * This is deliberately non-destructive: it does NOT modify docker-compose.yml or
 * nginx.conf. Instead, you can layer the generated compose file using:
 *   docker compose -f docker-compose.yml -f docker-compose.apps.generated.yml up
 * and include the generated nginx fragment from nginx.conf.
 */

/* eslint-disable no-console */

import * as fs from "fs";
import * as path from "path";

import type { AppDefinition, DockerServiceDef, NginxProxyDef } from "../src/apps/appTypes";
import { AppRegistry } from "../src/apps/AppRegistry";

interface ServiceWithApp {
  appId: string;
  service: DockerServiceDef;
}

interface ProxyWithApp {
  appId: string;
  proxy: NginxProxyDef;
}

interface EnvVarWithApp {
  appId: string;
  key: string;
  value: string;
}

function indent(level: number): string {
  return " ".repeat(level);
}

function serializeServices(services: ServiceWithApp[]): string {
  let out = "version: \"3.8\"\nservices:\n";

  for (const { appId, service } of services) {
    const name = `${appId}_${service.name}`;
    out += `${indent(2)}${name}:\n`;
    out += `${indent(4)}image: ${service.image}\n`;

    if (service.ports && service.ports.length > 0) {
      out += `${indent(4)}ports:\n`;
      for (const p of service.ports) {
        out += `${indent(6)}- \"${p}\"\n`;
      }
    }

    if (service.volumes && service.volumes.length > 0) {
      out += `${indent(4)}volumes:\n`;
      for (const v of service.volumes) {
        out += `${indent(6)}- \"${v}\"\n`;
      }
    }

    if (service.environment && Object.keys(service.environment).length > 0) {
      out += `${indent(4)}environment:\n`;
      for (const [key, value] of Object.entries(service.environment)) {
        out += `${indent(6)}- ${key}=${value}\n`;
      }
    }

    if (service.depends_on && service.depends_on.length > 0) {
      out += `${indent(4)}depends_on:\n`;
      for (const dep of service.depends_on) {
        out += `${indent(6)}- ${dep}\n`;
      }
    }

    if (service.restart) {
      out += `${indent(4)}restart: ${service.restart}\n`;
    }

    out += "\n";
  }

  return out;
}

function serializeProxies(proxies: ProxyWithApp[]): string {
  const lines: string[] = [];

  lines.push("# Autogenerated by scripts/generate-compose.ts");
  lines.push("# Proxy definitions for app-provided backends");
  lines.push("");

  for (const { appId, proxy } of proxies) {
    lines.push(`# ${appId}`);
    lines.push(`location ${proxy.path} {`);
    lines.push(`  proxy_pass http://${proxy.upstream}/;`);

    if (proxy.websocket) {
      lines.push("  proxy_http_version 1.1;");
      lines.push("  proxy_set_header Upgrade $http_upgrade;");
      lines.push("  proxy_set_header Connection $connection_upgrade;");
      lines.push("  proxy_set_header Host $host;");
      lines.push("  proxy_set_header X-Real-IP $remote_addr;");
      lines.push("  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;");
      lines.push("  proxy_set_header X-Forwarded-Proto $scheme;");
      lines.push("  proxy_read_timeout 86400s;");
    } else {
      lines.push("  proxy_set_header Host $host;");
      lines.push("  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;");
      lines.push("  proxy_set_header X-Forwarded-Proto $scheme;");
    }

    lines.push("}");
    lines.push("");
  }

  return lines.join("\n");
}

function serializeFrontendEnv(envVars: EnvVarWithApp[]): string {
  if (envVars.length === 0) {
    return "";
  }

  const merged: Record<string, string> = {};

  for (const { key, value } of envVars) {
    merged[key] = value;
  }

  let out = "";
  out += `${indent(2)}frontend:\n`;
  out += `${indent(4)}environment:\n`;

  for (const [key, value] of Object.entries(merged)) {
    const escaped = value.replace(/"/g, '\\"');
    out += `${indent(6)}${key}: "${escaped}"\n`;
  }

  out += "\n";
  return out;
}

function collectFromRegistry(registry: Record<string, AppDefinition>) {
  const services: ServiceWithApp[] = [];
  const proxies: ProxyWithApp[] = [];
  const envVars: EnvVarWithApp[] = [];

  for (const app of Object.values(registry)) {
    if (app.services) {
      for (const svc of app.services) {
        services.push({ appId: app.id, service: svc });
      }
    }

    if (app.proxy) {
      for (const proxy of app.proxy) {
        proxies.push({ appId: app.id, proxy });
      }
    }

    if (app.env) {
      for (const [key, value] of Object.entries(app.env)) {
        envVars.push({ appId: app.id, key, value });
      }
    }
  }

  return { services, proxies, envVars };
}

function main() {
  // Since we are now in devussy-web/scripts, rootDir is one level up
  const devussyWebDir = path.resolve(__dirname, "..");

  const { services, proxies, envVars } = collectFromRegistry(AppRegistry);

  const composeOutPath = path.join(devussyWebDir, "docker-compose.apps.generated.yml");
  const nginxOutPath = path.join(devussyWebDir, "nginx", "conf.d", "apps.generated.conf");

  const composeParts: string[] = [
    "# Autogenerated file. Combine with docker-compose.yml using:",
    "#   docker compose -f docker-compose.yml -f docker-compose.apps.generated.yml up",
    "",
    serializeServices(services),
  ];

  const frontendEnvBlock = serializeFrontendEnv(envVars);
  if (frontendEnvBlock) {
    composeParts.push(frontendEnvBlock);
  }

  const composeContent = composeParts.join("\n");

  fs.writeFileSync(composeOutPath, composeContent, { encoding: "utf-8" });

  fs.mkdirSync(path.dirname(nginxOutPath), { recursive: true });
  const proxyContent = serializeProxies(proxies);
  fs.writeFileSync(nginxOutPath, proxyContent, { encoding: "utf-8" });

  console.log(`[generate-compose] Wrote ${services.length} services to ${composeOutPath}`);
  console.log(`[generate-compose] Wrote ${proxies.length} proxy blocks to ${nginxOutPath}`);
  if (envVars.length > 0) {
    console.log(`[generate-compose] Collected ${envVars.length} frontend env vars`);
  }
}

if (require.main === module) {
  main();
}
